{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Learning Management System (LMS)","text":""},{"location":"#overview","title":"Overview","text":"<p>The Learning Management System (LMS) is a web application that helps manage learning resources, user authentication, file management, and real-time interaction with an AI assistant. This platform is built with FastAPI for the backend and uses modern web technologies to deliver a seamless learning experience.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>User Authentication - Secure login and registration system</li> <li>File Management - Upload, download, and manage learning materials</li> <li>AI Integration - Intelligent chatbot assistant for learning support</li> <li>URL Management - Track active URLs for learning resources</li> <li>User Profiles - Personalized user experience</li> </ul>"},{"location":"#architecture","title":"Architecture","text":"<pre><code>graph LR\n    Client[Web Browser] -- HTTP --&gt; API[FastAPI Backend]\n    API -- SQL --&gt; DB[(PostgreSQL)]\n    API -- Auth --&gt; JWT[JWT Provider]\n    API -- Files --&gt; Storage[File Storage]\n    API -- AI Queries --&gt; OpenAI[OpenAI API]</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"InstallationConfigurationRun the Application <pre><code># Clone the repository\ngit clone https://github.com/gadm21/LMS.git\ncd LMS\n\n# Set up virtual environment\npython -m venv .venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\n\n# Install dependencies\npip install -r requirements.txt\n</code></pre> <pre><code># Set up environment variables\nexport DATABASE_URL=\"postgresql://user:password@localhost:5432/lms_db\"\nexport SECRET_KEY=\"your-secret-key\"\nexport OPENAI_API_KEY=\"your-openai-api-key\"\n</code></pre> <pre><code># Start the server\nuvicorn server.main:app --reload --port 7050\n</code></pre>"},{"location":"#deployment","title":"Deployment","text":"<p>The LMS is deployed on Vercel:</p> <ul> <li>Production URL: lms-swart-five.vercel.app</li> </ul>"},{"location":"#welcome-to-the-lms-platform","title":"Welcome to the LMS Platform","text":"<ul> <li> <p>:material-school: Modern Learning Experience   Engaging platform designed for effective education delivery and management</p> </li> <li> <p>:material-account-group: Personalized Learning   AI-driven content adaptation to optimize student engagement and success</p> </li> <li> <p>:material-chart-line: Advanced Analytics   Comprehensive insights to track progress and improve outcomes</p> </li> <li> <p>:material-shield-account: Secure &amp; Reliable   Enterprise-grade security for your sensitive educational data</p> </li> </ul>"},{"location":"#platform-overview","title":"Platform Overview","text":"<p>The LMS Platform is a next-generation learning management system built with modern technologies. Our solution combines powerful AI capabilities with intuitive design to enhance the educational experience for both educators and learners.</p>"},{"location":"#api-documentation","title":"API Documentation","text":"<p>The REST API documentation is available at:</p> <ul> <li>Local: <code>http://localhost:7050/docs</code></li> <li>Production: <code>https://lms-swart-five.vercel.app/docs</code></li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! See the contributing guide for how to get started.</p>"},{"location":"api/auth/","title":"Authentication API","text":""},{"location":"api/auth/#overview","title":"Overview","text":"<p>The LMS Platform uses JWT (JSON Web Token) based authentication to secure API endpoints. This approach provides stateless authentication with secure token exchange.</p>"},{"location":"api/auth/#authentication-flow","title":"Authentication Flow","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant API\n    participant Database\n\n    Client-&gt;&gt;API: POST /register (credentials)\n    API-&gt;&gt;Database: Create User\n    Database--&gt;&gt;API: User Created\n    API--&gt;&gt;Client: Success Response\n\n    Client-&gt;&gt;API: POST /token (credentials)\n    API-&gt;&gt;Database: Validate Credentials\n    Database--&gt;&gt;API: Credentials Valid\n    API--&gt;&gt;Client: JWT Access Token\n\n    Client-&gt;&gt;API: Request with Bearer Token\n    API-&gt;&gt;API: Validate Token\n    API--&gt;&gt;Client: Protected Resource</code></pre>"},{"location":"api/auth/#api-endpoints","title":"API Endpoints","text":""},{"location":"api/auth/#register","title":"Register","text":"<p>Register a new user in the system.</p> <p>Endpoint: <code>/register</code> Method: <code>POST</code> Request Body:</p> <pre><code>{\n  \"username\": \"string\",\n  \"password\": \"string\"\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"message\": \"Registered successfully\",\n  \"userId\": 123\n}\n</code></pre>"},{"location":"api/auth/#login-token","title":"Login (Token)","text":"<p>Obtain an access token.</p> <p>Endpoint: <code>/token</code> Method: <code>POST</code> Form Data: - <code>username</code>: Username - <code>password</code>: Password</p> <p>Response:</p> <pre><code>{\n  \"access_token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\",\n  \"token_type\": \"bearer\"\n}\n</code></pre>"},{"location":"api/auth/#authentication-code-reference","title":"Authentication Code Reference","text":"<p>Here's the auto-generated documentation from the code:</p>"},{"location":"api/auth/#server.auth","title":"<code>server.auth</code>","text":"<p>Authentication Module for LMS Platform.</p> <p>This module handles all aspects of user authentication including: - Password hashing and verification - JWT token generation and validation - User authentication logic - Dependency injection for database and current user</p>"},{"location":"api/auth/#server.auth-classes","title":"Classes","text":""},{"location":"api/auth/#server.auth-functions","title":"Functions","text":""},{"location":"api/auth/#server.auth.authenticate_user","title":"<code>authenticate_user(db: Session, username: str, password: str) -&gt; Optional[User]</code>","text":"<p>Authenticate a user with username and password.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Database session</p> required <code>username</code> <code>str</code> <p>The username to authenticate</p> required <code>password</code> <code>str</code> <p>The password to verify</p> required <p>Returns:</p> Type Description <code>Optional[User]</code> <p>Optional[User]: The authenticated user object or None if authentication fails</p> Source code in <code>server/auth.py</code> <pre><code>def authenticate_user(db: Session, username: str, password: str) -&gt; Optional[User]:\n    \"\"\"Authenticate a user with username and password.\n\n    Args:\n        db: Database session\n        username: The username to authenticate\n        password: The password to verify\n\n    Returns:\n        Optional[User]: The authenticated user object or None if authentication fails\n    \"\"\"\n    user = db.query(User).filter(User.username == username).first()\n    if not user or not verify_password(password, user.hashed_password):\n        return None\n    return user\n</code></pre>"},{"location":"api/auth/#server.auth.create_access_token","title":"<code>create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -&gt; str</code>","text":"<p>Create a JWT access token.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The data to encode in the token, typically includes the 'sub' field</p> required <code>expires_delta</code> <code>Optional[timedelta]</code> <p>Optional expiration time, either as timedelta or minutes (int)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The encoded JWT token</p> Source code in <code>server/auth.py</code> <pre><code>def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -&gt; str:\n    \"\"\"Create a JWT access token.\n\n    Args:\n        data: The data to encode in the token, typically includes the 'sub' field\n        expires_delta: Optional expiration time, either as timedelta or minutes (int)\n\n    Returns:\n        str: The encoded JWT token\n    \"\"\"\n    to_encode = data.copy()\n    # If expires_delta is an int (minutes), convert to timedelta\n    if isinstance(expires_delta, int):\n        expires_delta = timedelta(minutes=expires_delta)\n    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=15))\n    to_encode.update({\"exp\": expire})\n    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n</code></pre>"},{"location":"api/auth/#server.auth.get_current_user","title":"<code>get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)) -&gt; User</code>  <code>async</code>","text":"<p>Get the current authenticated user from a JWT token.</p> <p>This function is used as a FastAPI dependency to inject the current user into route handlers that require authentication.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>The JWT token from the Authorization header</p> <code>Depends(oauth2_scheme)</code> <code>db</code> <code>Session</code> <p>Database session</p> <code>Depends(get_db)</code> <p>Returns:</p> Name Type Description <code>User</code> <code>User</code> <p>The authenticated user object</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>401 error if token is invalid or user doesn't exist</p> Source code in <code>server/auth.py</code> <pre><code>async def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)) -&gt; User:\n    \"\"\"Get the current authenticated user from a JWT token.\n\n    This function is used as a FastAPI dependency to inject the current user\n    into route handlers that require authentication.\n\n    Args:\n        token: The JWT token from the Authorization header\n        db: Database session\n\n    Returns:\n        User: The authenticated user object\n\n    Raises:\n        HTTPException: 401 error if token is invalid or user doesn't exist\n    \"\"\"\n    credentials_exception = HTTPException(status_code=401, detail=\"Invalid credentials\")\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n    except JWTError:\n        raise credentials_exception\n\n    user = db.query(User).filter(User.username == username).first()\n    if user is None:\n        raise credentials_exception\n    return user\n</code></pre>"},{"location":"api/auth/#server.auth.get_db","title":"<code>get_db()</code>","text":"<p>Create and yield a database session.</p> <p>This function serves as a FastAPI dependency for database access. It ensures the database session is properly closed after use.</p> <p>Yields:</p> Name Type Description <code>Session</code> <p>A SQLAlchemy database session</p> Source code in <code>server/auth.py</code> <pre><code>def get_db():\n    \"\"\"Create and yield a database session.\n\n    This function serves as a FastAPI dependency for database access.\n    It ensures the database session is properly closed after use.\n\n    Yields:\n        Session: A SQLAlchemy database session\n    \"\"\"\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n</code></pre>"},{"location":"api/auth/#server.auth.get_password_hash","title":"<code>get_password_hash(password: str) -&gt; str</code>","text":"<p>Hash a password using bcrypt.</p> <p>Parameters:</p> Name Type Description Default <code>password</code> <code>str</code> <p>The plain text password to hash</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The hashed password</p> Source code in <code>server/auth.py</code> <pre><code>def get_password_hash(password: str) -&gt; str:\n    \"\"\"Hash a password using bcrypt.\n\n    Args:\n        password: The plain text password to hash\n\n    Returns:\n        str: The hashed password\n    \"\"\"\n    return pwd_context.hash(password)\n</code></pre>"},{"location":"api/auth/#server.auth.verify_password","title":"<code>verify_password(plain: str, hashed: str) -&gt; bool</code>","text":"<p>Verify a password against a hash.</p> <p>Parameters:</p> Name Type Description Default <code>plain</code> <code>str</code> <p>The plain text password</p> required <code>hashed</code> <code>str</code> <p>The hashed password to compare against</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if password matches, False otherwise</p> Source code in <code>server/auth.py</code> <pre><code>def verify_password(plain: str, hashed: str) -&gt; bool:\n    \"\"\"Verify a password against a hash.\n\n    Args:\n        plain: The plain text password\n        hashed: The hashed password to compare against\n\n    Returns:\n        bool: True if password matches, False otherwise\n    \"\"\"\n    return pwd_context.verify(plain, hashed)\n</code></pre>"},{"location":"api/db/","title":"Database Models","text":""},{"location":"api/db/#overview","title":"Overview","text":"<p>The LMS platform uses SQLAlchemy as its ORM (Object-Relational Mapping) layer to interact with a PostgreSQL database. The models defined here represent the database schema and provide an abstraction layer for database operations.</p>"},{"location":"api/db/#database-schema","title":"Database Schema","text":"<pre><code>erDiagram\n    User {\n        int id PK\n        string username\n        string password_hash\n    }\n    File {\n        int id PK\n        string filename\n        int user_id FK\n        string path\n        datetime created_at\n    }\n    Query {\n        int id PK\n        int user_id FK\n        string chat_id\n        string query_text\n        string response\n        datetime timestamp\n    }\n\n    User ||--o{ File : uploads\n    User ||--o{ Query : makes</code></pre>"},{"location":"api/db/#database-models_1","title":"Database Models","text":""},{"location":"api/db/#user-model","title":"User Model","text":"<p>The User model represents a registered user in the system.</p>"},{"location":"api/db/#server.db.User","title":"<code>server.db.User</code>","text":"<p>               Bases: <code>Base</code></p> <p>User model representing registered users in the system.</p> <p>This model stores user credentials and settings. The password is stored as a hash, never in plain text.</p> <p>Attributes:</p> Name Type Description <code>userId</code> <p>Unique identifier for the user</p> <code>username</code> <p>Unique username for authentication</p> <code>hashed_password</code> <p>Bcrypt hash of the user's password</p> <code>max_file_size</code> <p>Maximum allowed file size in bytes (default: 500MB)</p> <code>files</code> <p>Relationship to File objects uploaded by this user</p> <code>queries</code> <p>Relationship to Query objects created by this user</p> <code>sessions</code> <p>Relationship to Session objects for this user</p> Source code in <code>server/db.py</code> <pre><code>class User(Base):\n    \"\"\"User model representing registered users in the system.\n\n    This model stores user credentials and settings. The password is stored\n    as a hash, never in plain text.\n\n    Attributes:\n        userId: Unique identifier for the user\n        username: Unique username for authentication\n        hashed_password: Bcrypt hash of the user's password\n        max_file_size: Maximum allowed file size in bytes (default: 500MB)\n        files: Relationship to File objects uploaded by this user\n        queries: Relationship to Query objects created by this user\n        sessions: Relationship to Session objects for this user\n    \"\"\"\n    __tablename__ = \"User\"\n    userId = Column(Integer, primary_key=True, autoincrement=True, index=True)\n    username = Column(String, unique=True, index=True, nullable=False)\n    hashed_password = Column(String)\n    max_file_size = Column(Integer, default=524288000)  # 500MB default max file size\n\n    # Relationships\n    files = relationship(\"File\", back_populates=\"user\")\n    queries = relationship(\"Query\", back_populates=\"user\")\n    sessions = relationship(\"Session\", back_populates=\"user\")\n</code></pre>"},{"location":"api/db/#base-model","title":"Base Model","text":"<p>All models inherit from the SQLAlchemy Base class.</p>"},{"location":"api/db/#server.db.Base","title":"<code>server.db.Base = declarative_base()</code>  <code>module-attribute</code>","text":""},{"location":"api/db/#database-connection","title":"Database Connection","text":"<p>The database connection is established in the main application and provides a dependency for all routes.</p>"},{"location":"api/db/#server.db","title":"<code>server.db</code>","text":"<p>Database Models Module for LMS Platform.</p> <p>This module defines the database models and connection setup for the LMS platform. It includes the User model and database connection configuration.</p>"},{"location":"api/db/#server.db-classes","title":"Classes","text":""},{"location":"api/db/#server.db.File","title":"<code>File</code>","text":"<p>               Bases: <code>Base</code></p> <p>File model representing files uploaded by users.</p> <p>Attributes:</p> Name Type Description <code>fileId</code> <p>Unique identifier for the file</p> <code>filename</code> <p>Name of the uploaded file</p> <code>userId</code> <p>Foreign key to the user who uploaded the file</p> <code>path</code> <p>Path where the file is stored on the server (nullable)</p> <code>size</code> <p>Size of the file in bytes</p> <code>content</code> <p>Binary content of the file</p> <code>content_type</code> <p>MIME type of the file</p> <code>uploaded_at</code> <p>Timestamp when the file was uploaded</p> <code>user</code> <p>Relationship to the User who owns this file</p> <code>versions</code> <p>Relationship to FileVersion objects for this file</p> <code>metadata</code> <p>Relationship to FileMetadata objects for this file</p> Source code in <code>server/db.py</code> <pre><code>class File(Base):\n    \"\"\"File model representing files uploaded by users.\n\n    Attributes:\n        fileId: Unique identifier for the file\n        filename: Name of the uploaded file\n        userId: Foreign key to the user who uploaded the file\n        path: Path where the file is stored on the server (nullable)\n        size: Size of the file in bytes\n        content: Binary content of the file\n        content_type: MIME type of the file\n        uploaded_at: Timestamp when the file was uploaded\n        user: Relationship to the User who owns this file\n        versions: Relationship to FileVersion objects for this file\n        metadata: Relationship to FileMetadata objects for this file\n    \"\"\"\n    __tablename__ = \"File\"\n    fileId = Column(Integer, primary_key=True, autoincrement=True, index=True)\n    filename = Column(String, nullable=False)\n    userId = Column(Integer, ForeignKey(\"User.userId\"), nullable=False)\n    path = Column(String, nullable=True)  # Now nullable since we store content in DB\n    size = Column(Integer, nullable=False)\n    content = Column(LargeBinary, nullable=True)  # Binary content of the file\n    content_type = Column(String(255), nullable=True)  # MIME type\n    uploaded_at = Column(DateTime, default=datetime.utcnow)\n\n    # Relationships\n    user = relationship(\"User\", back_populates=\"files\")\n    versions = relationship(\"FileVersion\", back_populates=\"file\", cascade=\"all, delete-orphan\")\n    file_metadata = relationship(\"FileMetadata\", back_populates=\"file\", cascade=\"all, delete-orphan\")\n</code></pre>"},{"location":"api/db/#server.db.FileMetadata","title":"<code>FileMetadata</code>","text":"<p>               Bases: <code>Base</code></p> <p>FileMetadata model for storing additional file properties.</p> <p>Attributes:</p> Name Type Description <code>metadataId</code> <p>Unique identifier for the metadata entry</p> <code>fileId</code> <p>Foreign key to the file this metadata belongs to</p> <code>key</code> <p>Name of the metadata property</p> <code>value</code> <p>Value of the metadata property</p> <code>created_at</code> <p>Timestamp when the metadata was created</p> <code>file</code> <p>Relationship to the File this metadata belongs to</p> Source code in <code>server/db.py</code> <pre><code>class FileMetadata(Base):\n    \"\"\"FileMetadata model for storing additional file properties.\n\n    Attributes:\n        metadataId: Unique identifier for the metadata entry\n        fileId: Foreign key to the file this metadata belongs to\n        key: Name of the metadata property\n        value: Value of the metadata property\n        created_at: Timestamp when the metadata was created\n        file: Relationship to the File this metadata belongs to\n    \"\"\"\n    __tablename__ = \"FileMetadata\"\n    metadataId = Column(Integer, primary_key=True, autoincrement=True, index=True)\n    fileId = Column(Integer, ForeignKey(\"File.fileId\"), nullable=False)\n    key = Column(String(255), nullable=False)\n    value = Column(Text, nullable=True)\n    created_at = Column(DateTime, default=datetime.utcnow)\n\n    # Relationships\n    file = relationship(\"File\", back_populates=\"file_metadata\")\n\n    # Ensure each file can only have one entry for a specific key\n    __table_args__ = (UniqueConstraint('fileId', 'key', name='_file_metadata_key_uc'),)\n</code></pre>"},{"location":"api/db/#server.db.FileVersion","title":"<code>FileVersion</code>","text":"<p>               Bases: <code>Base</code></p> <p>FileVersion model for tracking different versions of files.</p> <p>Attributes:</p> Name Type Description <code>versionId</code> <p>Unique identifier for the version</p> <code>fileId</code> <p>Foreign key to the file this version belongs to</p> <code>userId</code> <p>Foreign key to the user who created this version</p> <code>content</code> <p>Binary content of this version</p> <code>size</code> <p>Size of the file version in bytes</p> <code>version_number</code> <p>Sequential version number for this file</p> <code>created_at</code> <p>Timestamp when the version was created</p> <code>file</code> <p>Relationship to the File this version belongs to</p> Source code in <code>server/db.py</code> <pre><code>class FileVersion(Base):\n    \"\"\"FileVersion model for tracking different versions of files.\n\n    Attributes:\n        versionId: Unique identifier for the version\n        fileId: Foreign key to the file this version belongs to\n        userId: Foreign key to the user who created this version\n        content: Binary content of this version\n        size: Size of the file version in bytes\n        version_number: Sequential version number for this file\n        created_at: Timestamp when the version was created\n        file: Relationship to the File this version belongs to\n    \"\"\"\n    __tablename__ = \"FileVersion\"\n    versionId = Column(Integer, primary_key=True, autoincrement=True, index=True)\n    fileId = Column(Integer, ForeignKey(\"File.fileId\"), nullable=False)\n    userId = Column(Integer, ForeignKey(\"User.userId\"), nullable=False)\n    content = Column(LargeBinary, nullable=True)\n    size = Column(Integer, nullable=False)\n    version_number = Column(Integer, nullable=False)\n    created_at = Column(DateTime, default=datetime.utcnow)\n\n    # Relationships\n    file = relationship(\"File\", back_populates=\"versions\")\n\n    # Ensure each file can only have one version with a specific number\n    __table_args__ = (UniqueConstraint('fileId', 'version_number', name='_file_version_uc'),)\n</code></pre>"},{"location":"api/db/#server.db.Query","title":"<code>Query</code>","text":"<p>               Bases: <code>Base</code></p> <p>Query model representing AI queries made by users.</p> <p>Attributes:</p> Name Type Description <code>queryId</code> <p>Unique identifier for the query</p> <code>userId</code> <p>Foreign key to the user who made the query</p> <code>chatId</code> <p>Identifier for grouping related queries into conversations</p> <code>query_text</code> <p>The text of the user's query</p> <code>response</code> <p>The AI response to the query</p> <code>created_at</code> <p>Timestamp when the query was made</p> <code>user</code> <p>Relationship to the User who made this query</p> Source code in <code>server/db.py</code> <pre><code>class Query(Base):\n    \"\"\"Query model representing AI queries made by users.\n\n    Attributes:\n        queryId: Unique identifier for the query\n        userId: Foreign key to the user who made the query\n        chatId: Identifier for grouping related queries into conversations\n        query_text: The text of the user's query\n        response: The AI response to the query\n        created_at: Timestamp when the query was made\n        user: Relationship to the User who made this query\n    \"\"\"\n    __tablename__ = \"Query\"\n    queryId = Column(Integer, primary_key=True, autoincrement=True, index=True)\n    userId = Column(Integer, ForeignKey(\"User.userId\"), nullable=False)\n    chatId = Column(String, nullable=True)\n    query_text = Column(Text, nullable=False)\n    response = Column(Text, nullable=True)\n    created_at = Column(DateTime, default=datetime.utcnow)\n\n    # Relationships\n    user = relationship(\"User\", back_populates=\"queries\")\n</code></pre>"},{"location":"api/db/#server.db.Session","title":"<code>Session</code>","text":"<p>               Bases: <code>Base</code></p> <p>Session model for tracking user login sessions.</p> <p>Attributes:</p> Name Type Description <code>sessionId</code> <p>Unique identifier for the session</p> <code>userId</code> <p>Foreign key to the user who owns this session</p> <code>token</code> <p>Session token for authentication</p> <code>expires_at</code> <p>Timestamp when the session expires</p> <code>user</code> <p>Relationship to the User who owns this session</p> Source code in <code>server/db.py</code> <pre><code>class Session(Base):\n    \"\"\"Session model for tracking user login sessions.\n\n    Attributes:\n        sessionId: Unique identifier for the session\n        userId: Foreign key to the user who owns this session\n        token: Session token for authentication\n        expires_at: Timestamp when the session expires\n        user: Relationship to the User who owns this session\n    \"\"\"\n    __tablename__ = \"Session\"\n    sessionId = Column(Integer, primary_key=True, autoincrement=True, index=True)\n    userId = Column(Integer, ForeignKey(\"User.userId\"), nullable=False)\n    token = Column(String, nullable=False)\n    expires_at = Column(DateTime, nullable=False)\n\n    # Relationships\n    user = relationship(\"User\", back_populates=\"sessions\")\n</code></pre>"},{"location":"api/db/#server.db.User","title":"<code>User</code>","text":"<p>               Bases: <code>Base</code></p> <p>User model representing registered users in the system.</p> <p>This model stores user credentials and settings. The password is stored as a hash, never in plain text.</p> <p>Attributes:</p> Name Type Description <code>userId</code> <p>Unique identifier for the user</p> <code>username</code> <p>Unique username for authentication</p> <code>hashed_password</code> <p>Bcrypt hash of the user's password</p> <code>max_file_size</code> <p>Maximum allowed file size in bytes (default: 500MB)</p> <code>files</code> <p>Relationship to File objects uploaded by this user</p> <code>queries</code> <p>Relationship to Query objects created by this user</p> <code>sessions</code> <p>Relationship to Session objects for this user</p> Source code in <code>server/db.py</code> <pre><code>class User(Base):\n    \"\"\"User model representing registered users in the system.\n\n    This model stores user credentials and settings. The password is stored\n    as a hash, never in plain text.\n\n    Attributes:\n        userId: Unique identifier for the user\n        username: Unique username for authentication\n        hashed_password: Bcrypt hash of the user's password\n        max_file_size: Maximum allowed file size in bytes (default: 500MB)\n        files: Relationship to File objects uploaded by this user\n        queries: Relationship to Query objects created by this user\n        sessions: Relationship to Session objects for this user\n    \"\"\"\n    __tablename__ = \"User\"\n    userId = Column(Integer, primary_key=True, autoincrement=True, index=True)\n    username = Column(String, unique=True, index=True, nullable=False)\n    hashed_password = Column(String)\n    max_file_size = Column(Integer, default=524288000)  # 500MB default max file size\n\n    # Relationships\n    files = relationship(\"File\", back_populates=\"user\")\n    queries = relationship(\"Query\", back_populates=\"user\")\n    sessions = relationship(\"Session\", back_populates=\"user\")\n</code></pre>"},{"location":"api/routes/","title":"API Routes","text":""},{"location":"api/routes/#overview","title":"Overview","text":"<p>The LMS Platform provides a comprehensive REST API for interacting with the system. All endpoints require authentication via JWT token (except for registration and login).</p>"},{"location":"api/routes/#base-url","title":"Base URL","text":"<p>Endpoint: <code>/upload</code> Method: <code>POST</code> Authorization: Bearer Token Form Data: - <code>file</code>: The file to upload</p> <p>Response:</p> <pre><code>{\n  \"filename\": \"example.pdf\",\n  \"size\": 1024\n}\n</code></pre>"},{"location":"api/routes/#list-files","title":"List Files","text":"<p>Get a list of all files uploaded by the authenticated user.</p> <p>Endpoint: <code>/files</code> Method: <code>GET</code> Authorization: Bearer Token</p> <p>Response:</p> <pre><code>[\n  \"file1.pdf\",\n  \"file2.jpg\",\n  \"file3.docx\"\n]\n</code></pre>"},{"location":"api/routes/#download-file","title":"Download File","text":"<p>Download a specific file.</p> <p>Endpoint: <code>/download/{filename}</code> Method: <code>GET</code> Authorization: Bearer Token URL Parameters: - <code>filename</code>: The name of the file to download</p> <p>Response: Binary file content</p>"},{"location":"api/routes/#delete-file","title":"Delete File","text":"<p>Delete a specific file.</p> <p>Endpoint: <code>/delete/{filename}</code> Method: <code>DELETE</code> Authorization: Bearer Token URL Parameters: - <code>filename</code>: The name of the file to delete</p> <p>Response:</p> <pre><code>{\n  \"message\": \"File 'example.pdf' deleted successfully.\"\n}\n</code></pre>"},{"location":"api/routes/#user-management","title":"User Management","text":""},{"location":"api/routes/#delete-user","title":"Delete User","text":"<p>Delete a user account.</p> <p>Endpoint: <code>/user/{username}</code> Method: <code>DELETE</code> Authorization: Bearer Token URL Parameters: - <code>username</code>: The username of the account to delete</p> <p>Response:</p> <pre><code>{\n  \"message\": \"User 'username' deleted successfully.\"\n}\n</code></pre>"},{"location":"api/routes/#ai-assistant","title":"AI Assistant","text":""},{"location":"api/routes/#query","title":"Query","text":"<p>Send a query to the AI assistant.</p> <p>Endpoint: <code>/query</code> Method: <code>POST</code> Authorization: Bearer Token Request Body:</p> <pre><code>{\n  \"query\": \"What is machine learning?\",\n  \"chatId\": \"chat123\",\n  \"pageContent\": \"Optional content from current page\"\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"userId\": 123,\n  \"username\": \"user123\",\n  \"query\": \"What is machine learning?\",\n  \"chatId\": \"chat123\",\n  \"pageContent\": \"Optional content from current page\",\n  \"message\": \"Query received\",\n  \"response\": \"Machine learning is a branch of artificial intelligence...\"\n}\n</code></pre>"},{"location":"api/routes/#misc-endpoints","title":"Misc Endpoints","text":""},{"location":"api/routes/#active-url","title":"Active URL","text":"<p>Report an active URL being viewed by the user.</p> <p>Endpoint: <code>/active_url</code> Method: <code>POST</code> Request Body:</p> <pre><code>{\n  \"url\": \"https://example.com/lesson\",\n  \"title\": \"Lesson: Introduction to Python\"\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"data\": {\n    \"status\": \"success\"\n  }\n}\n</code></pre>"},{"location":"api/routes/#profile","title":"Profile","text":"<p>Get user profile information.</p> <p>Endpoint: <code>/profile</code> Method: <code>GET</code> </p> <p>Response:</p> <pre><code>{\n  \"name\": \"Gad Mohamed\",\n  \"profession\": \"AI Engineer\",\n  \"favorite_color\": \"Blue\",\n  \"spirit_animal\": \"Owl\"\n}\n</code></pre>"},{"location":"api/routes/#routes-code-reference","title":"Routes Code Reference","text":""},{"location":"api/routes/#server.routes","title":"<code>server.routes</code>","text":"<p>API Routes Module for LMS Platform.</p> <p>This module defines all the API endpoints for the LMS platform, including: - User authentication and management - File operations (upload, download, listing, deletion) - AI query handling - URL tracking - User profile information</p>"},{"location":"api/routes/#server.routes-classes","title":"Classes","text":""},{"location":"api/routes/#server.routes-functions","title":"Functions","text":""},{"location":"api/routes/#server.routes.active_url","title":"<code>active_url(request: Request)</code>  <code>async</code>","text":"<p>Track active URL being viewed by user.</p> <p>Records the URL and page title the user is currently viewing. No authentication required for this endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The HTTP request containing the URL data</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Success status</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>400 if URL is missing</p> Source code in <code>server/routes.py</code> <pre><code>@router.post(\"/active_url\")\nasync def active_url(request: Request):\n    \"\"\"Track active URL being viewed by user.\n\n    Records the URL and page title the user is currently viewing.\n    No authentication required for this endpoint.\n\n    Args:\n        request: The HTTP request containing the URL data\n\n    Returns:\n        dict: Success status\n\n    Raises:\n        HTTPException: 400 if URL is missing\n    \"\"\"\n    \"\"\"\n    Receive active URL updates from the extension and return a success response.\n    Expected POST data:\n        url (str): The current active URL\n        title (str, optional): The page title\n    Returns:\n        JSON response with status acknowledgment\n    \"\"\"\n    try:\n        # Log request start\n        log_request_start('/active_url', request.method, dict(request.headers), request.client.host if request.client else None)\n\n        # First check if there's any content in the request body\n        body_bytes = await request.body()\n        if not body_bytes:\n            log_error(\"Empty request body\", None, {\"endpoint\": \"/active_url\"}, \"/active_url\")\n            return JSONResponse({\"error\": \"Empty request body\"}, status_code=400)\n\n        # Try to parse the JSON body\n        try:\n            data = await request.json()\n            log_request_payload(data, '/active_url')\n        except json.JSONDecodeError as json_err:\n            log_error(f\"Invalid JSON: {str(json_err)}\", json_err, {\"endpoint\": \"/active_url\"}, \"/active_url\")\n            return JSONResponse({\"error\": f\"Invalid JSON in request body: {str(json_err)}\"}, status_code=400)\n        # Validate fields\n        url = data.get('url', '') if data else ''\n        title = data.get('title', '') if data else ''\n        log_validation('url', url, bool(url), '/active_url')\n        log_validation('title', title, bool(title), '/active_url')\n        if data is None:\n            log_error(\"No JSON data provided\", None, {\"endpoint\": \"/active_url\"}, \"/active_url\")\n            return JSONResponse({\"error\": \"No JSON data provided\"}, status_code=400)\n        if not url:\n            log_error(\"Missing URL\", None, {\"endpoint\": \"/active_url\"}, \"/active_url\")\n            return JSONResponse({\"error\": \"Missing URL\"}, status_code=400)\n        # Log URL details\n        logger.info(f\"[SERVER] Active URL: {url[:100]}\")\n        if title:\n            logger.info(f\"[SERVER] Page title: {title[:50]}\")\n        # Log response\n        response = {\"data\": {\"status\": \"success\"}}\n        log_response(200, response, '/active_url')\n        return JSONResponse(response, status_code=200)\n    except json.JSONDecodeError as json_err:\n        return JSONResponse({\"error\": f\"Invalid JSON in request body: {str(json_err)}\"}, status_code=400)\n    except Exception as e:\n        # Log errors\n        log_error(str(e), e, {\"endpoint\": \"/active_url\"}, \"/active_url\")\n        return JSONResponse({\"error\": str(e)}, status_code=500)\n</code></pre>"},{"location":"api/routes/#server.routes.delete_file","title":"<code>delete_file(fileId: int, user: User = Depends(get_current_user), db: SessionLocal = Depends(get_db))</code>","text":"<p>Delete a specific file by its ID.</p> <p>Deletes both the database record and the file on disk.</p> <p>Parameters:</p> Name Type Description Default <code>fileId</code> <code>int</code> <p>The ID of the file to delete</p> required <code>user</code> <code>User</code> <p>The authenticated user requesting the deletion</p> <code>Depends(get_current_user)</code> <code>db</code> <code>SessionLocal</code> <p>Database session dependency</p> <code>Depends(get_db)</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Confirmation message</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>404 if file not found</p> <code>HTTPException</code> <p>403 if trying to delete another user's file</p> Source code in <code>server/routes.py</code> <pre><code>@router.delete(\"/files/{fileId}\")\ndef delete_file(fileId: int, user: User = Depends(get_current_user), db: SessionLocal = Depends(get_db)):\n    \"\"\"Delete a specific file by its ID.\n\n    Deletes both the database record and the file on disk.\n\n    Args:\n        fileId: The ID of the file to delete\n        user: The authenticated user requesting the deletion\n        db: Database session dependency\n\n    Returns:\n        dict: Confirmation message\n\n    Raises:\n        HTTPException: 404 if file not found\n        HTTPException: 403 if trying to delete another user's file\n    \"\"\"\n    try:\n        # Query the database for the file record\n        file_record = db.query(DBFile).filter(DBFile.fileId == fileId).first()\n\n        # Check if file exists and belongs to the user\n        if not file_record:\n            raise HTTPException(status_code=404, detail=\"File not found\")\n\n        if file_record.userId != user.userId:\n            raise HTTPException(status_code=403, detail=\"You don't have permission to delete this file\")\n\n        # Get file information before deleting\n        filename = file_record.filename\n        filepath = file_record.path\n\n        # Delete the file from disk if it exists\n        try:\n            if os.path.exists(filepath):\n                os.remove(filepath)\n            else:\n                # Try the standard path pattern as fallback\n                user_folder = os.path.join(ASSETS_FOLDER, str(user.userId))\n                fallback_path = os.path.join(user_folder, filename)\n                if os.path.exists(fallback_path):\n                    os.remove(fallback_path)\n        except OSError as e:\n            # Continue even if file removal fails, as we still want to remove the database record\n            log_error(f\"Error removing file from disk: {str(e)}\", exc=e, endpoint=f\"/delete/{fileId}\")\n\n        # Delete the database record\n        db.delete(file_record)\n        db.commit()\n\n        return {\"message\": f\"File '{filename}' deleted successfully.\", \"fileId\": fileId}\n    except HTTPException:\n        raise\n    except Exception as e:\n        db.rollback()\n        log_error(f\"Error deleting file: {str(e)}\", exc=e, endpoint=f\"/delete/{fileId}\")\n        raise HTTPException(status_code=500, detail=f\"Error deleting file: {str(e)}\")\n</code></pre>"},{"location":"api/routes/#server.routes.delete_user","title":"<code>delete_user(username: str, current_user: User = Depends(get_current_user), db: SessionLocal = Depends(get_db))</code>","text":"<p>Delete a user account.</p> <p>Users can only delete their own accounts, not others.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The username of the account to delete</p> required <code>current_user</code> <code>User</code> <p>The authenticated user making the request</p> <code>Depends(get_current_user)</code> <code>db</code> <code>SessionLocal</code> <p>Database session dependency</p> <code>Depends(get_db)</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Confirmation message</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>403 if trying to delete another user's account</p> <code>HTTPException</code> <p>404 if user not found</p> Source code in <code>server/routes.py</code> <pre><code>@router.delete(\"/user/{username}\")\ndef delete_user(username: str, current_user: User = Depends(get_current_user), db: SessionLocal = Depends(get_db)):\n    \"\"\"Delete a user account.\n\n    Users can only delete their own accounts, not others.\n\n    Args:\n        username: The username of the account to delete\n        current_user: The authenticated user making the request\n        db: Database session dependency\n\n    Returns:\n        dict: Confirmation message\n\n    Raises:\n        HTTPException: 403 if trying to delete another user's account\n        HTTPException: 404 if user not found\n    \"\"\"\n    if current_user.username != username:\n        raise HTTPException(status_code=403, detail=\"You can only delete your own account.\")\n    user = db.query(User).filter(User.username == username).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    db.delete(user)\n    db.commit()\n    return {\"message\": f\"User '{username}' deleted successfully.\"}\n</code></pre>"},{"location":"api/routes/#server.routes.download_file","title":"<code>download_file(fileId: int, user: User = Depends(get_current_user), db: SessionLocal = Depends(get_db))</code>","text":"<p>Download a specific file by its ID.</p> <p>Retrieves the file record from the database before accessing the filesystem.</p> <p>Parameters:</p> Name Type Description Default <code>fileId</code> <code>int</code> <p>The ID of the file to download</p> required <code>user</code> <code>User</code> <p>The authenticated user requesting the download</p> <code>Depends(get_current_user)</code> <code>db</code> <code>SessionLocal</code> <p>Database session dependency</p> <code>Depends(get_db)</code> <p>Returns:</p> Name Type Description <code>FileResponse</code> <p>The file content as a download</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>404 if file not found</p> <code>HTTPException</code> <p>403 if trying to access another user's file</p> Source code in <code>server/routes.py</code> <pre><code>@router.get(\"/download/{fileId}\")\ndef download_file(fileId: int, user: User = Depends(get_current_user), db: SessionLocal = Depends(get_db)):\n    \"\"\"Download a specific file by its ID.\n\n    Retrieves the file record from the database before accessing the filesystem.\n\n    Args:\n        fileId: The ID of the file to download\n        user: The authenticated user requesting the download\n        db: Database session dependency\n\n    Returns:\n        FileResponse: The file content as a download\n\n    Raises:\n        HTTPException: 404 if file not found\n        HTTPException: 403 if trying to access another user's file\n    \"\"\"\n    try:\n        # Query the database for the file record\n        file_record = db.query(DBFile).filter(DBFile.fileId == fileId).first()\n\n        # Check if file exists and belongs to the user\n        if not file_record:\n            raise HTTPException(status_code=404, detail=\"File not found\")\n\n        if file_record.userId != user.userId:\n            raise HTTPException(status_code=403, detail=\"You don't have permission to access this file\")\n\n        # First try to get content directly from the database\n        if file_record.content is not None:\n            file_content = file_record.content\n        else:\n            # Fall back to the filesystem if content is not in the database\n            filepath = file_record.path\n            if filepath and os.path.exists(filepath):\n                with open(filepath, \"rb\") as f:\n                    file_content = f.read()\n            else:\n                # Try standard path as fallback\n                user_folder = os.path.join(ASSETS_FOLDER, str(user.userId))\n                fallback_path = os.path.join(user_folder, file_record.filename)\n\n                if os.path.exists(fallback_path):\n                    with open(fallback_path, \"rb\") as f:\n                        file_content = f.read()\n                else:\n                    # Check if we have any versions of this file\n                    latest_version = db.query(FileVersion).filter(\n                        FileVersion.fileId == fileId\n                    ).order_by(FileVersion.version_number.desc()).first()\n\n                    if latest_version and latest_version.content is not None:\n                        file_content = latest_version.content\n                    else:\n                        raise HTTPException(status_code=404, detail=\"File not found on server\")\n\n        # Determine content type\n        content_type = file_record.content_type\n        if not content_type:\n            # Look for content type in metadata\n            metadata = db.query(FileMetadata).filter(\n                FileMetadata.fileId == fileId,\n                FileMetadata.key == \"content_type\"\n            ).first()\n\n            if metadata and metadata.value:\n                content_type = metadata.value\n            else:\n                # Guess from filename\n                import mimetypes\n                content_type = mimetypes.guess_type(file_record.filename)[0] or \"application/octet-stream\"\n\n        # Stream the file from memory\n        def iterfile():\n            yield file_content\n\n        return StreamingResponse(\n            iterfile(), \n            media_type=content_type, \n            headers={\"Content-Disposition\": f\"attachment; filename={quote(file_record.filename)}\"}\n        )\n    except HTTPException:\n        raise\n    except Exception as e:\n        log_error(f\"Error downloading file: {str(e)}\", exc=e, endpoint=f\"/download/{fileId}\")\n        raise HTTPException(status_code=500, detail=f\"Error downloading file: {str(e)}\")\n</code></pre>"},{"location":"api/routes/#server.routes.list_files","title":"<code>list_files(user: User = Depends(get_current_user), db: SessionLocal = Depends(get_db))</code>","text":"<p>List all files uploaded by the authenticated user.</p> <p>Retrieves files from the database instead of checking the filesystem directly.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>The authenticated user whose files to list</p> <code>Depends(get_current_user)</code> <code>db</code> <code>SessionLocal</code> <p>Database session dependency</p> <code>Depends(get_db)</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>List of files with their metadata</p> Source code in <code>server/routes.py</code> <pre><code>@router.get(\"/files\")\ndef list_files(user: User = Depends(get_current_user), db: SessionLocal = Depends(get_db)):\n    \"\"\"List all files uploaded by the authenticated user.\n\n    Retrieves files from the database instead of checking the filesystem directly.\n\n    Args:\n        user: The authenticated user whose files to list\n        db: Database session dependency\n\n    Returns:\n        dict: List of files with their metadata\n    \"\"\"\n    try:\n        # Query the database for files owned by this user\n        files = db.query(DBFile).filter(DBFile.userId == user.userId).all()\n\n        # Format the response with file metadata\n        file_list = [\n            {\n                \"fileId\": file.fileId,\n                \"filename\": file.filename,\n                \"size\": file.size,\n                \"uploaded_at\": file.uploaded_at\n            } for file in files\n        ]\n\n        return {\"files\": file_list, \"count\": len(file_list)}\n    except Exception as e:\n        log_error(f\"Error listing files: {str(e)}\", exc=e, endpoint=\"/files\")\n        raise HTTPException(status_code=500, detail=f\"Error listing files: {str(e)}\")\n</code></pre>"},{"location":"api/routes/#server.routes.login","title":"<code>login(form_data: OAuth2PasswordRequestForm = Depends(), db: SessionLocal = Depends(get_db))</code>","text":"<p>Authenticate user and generate access token.</p> <p>This endpoint conforms to the OAuth2 password flow standard.</p> <p>Parameters:</p> Name Type Description Default <code>form_data</code> <code>OAuth2PasswordRequestForm</code> <p>OAuth2 form containing username and password</p> <code>Depends()</code> <code>db</code> <code>SessionLocal</code> <p>Database session dependency</p> <code>Depends(get_db)</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>JWT access token and token type</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>401 if authentication fails</p> Source code in <code>server/routes.py</code> <pre><code>@router.post(\"/token\")\ndef login(form_data: OAuth2PasswordRequestForm = Depends(), db: SessionLocal = Depends(get_db)):\n    \"\"\"Authenticate user and generate access token.\n\n    This endpoint conforms to the OAuth2 password flow standard.\n\n    Args:\n        form_data: OAuth2 form containing username and password\n        db: Database session dependency\n\n    Returns:\n        dict: JWT access token and token type\n\n    Raises:\n        HTTPException: 401 if authentication fails\n    \"\"\"\n    user = authenticate_user(db, form_data.username, form_data.password)\n    if not user:\n        raise HTTPException(status_code=400, detail=\"Invalid credentials\")\n    access_token = create_access_token(\n        data={\"sub\": user.username},\n        expires_delta=ACCESS_TOKEN_EXPIRE_MINUTES\n    )\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n</code></pre>"},{"location":"api/routes/#server.routes.profile","title":"<code>profile()</code>","text":"<p>Get user profile information.</p> <p>This is a static endpoint that returns hardcoded profile information. In a real application, this would fetch data from the database.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Profile information</p> Source code in <code>server/routes.py</code> <pre><code>@router.get('/profile')\ndef profile():\n    \"\"\"Get user profile information.\n\n    This is a static endpoint that returns hardcoded profile information.\n    In a real application, this would fetch data from the database.\n\n    Returns:\n        dict: Profile information\n    \"\"\"\n    return {\n        \"name\": \"Gad Mohamed\",\n        \"profession\": \"AI Engineer\",\n        \"favorite_color\": \"Blue\",\n        \"spirit_animal\": \"Owl\"\n    }\n</code></pre>"},{"location":"api/routes/#server.routes.queryEndpoint","title":"<code>queryEndpoint(request: Request, user: User = Depends(get_current_user), db: SessionLocal = Depends(get_db))</code>  <code>async</code>","text":"<p>Process an AI query from a user.</p> <p>Sends the query to the OpenAI API and returns the response. The query and response are associated with a chat ID for maintaining conversation context. All queries and responses are stored in the database for future reference.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The HTTP request containing the query data</p> required <code>user</code> <code>User</code> <p>The authenticated user making the query</p> <code>Depends(get_current_user)</code> <code>db</code> <code>SessionLocal</code> <p>Database session dependency</p> <code>Depends(get_db)</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The AI response along with query details</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>400 if required parameters are missing</p> <code>HTTPException</code> <p>500 if OpenAI API call fails</p> Source code in <code>server/routes.py</code> <pre><code>@router.post(\"/query\")\nasync def queryEndpoint(request: Request, user: User = Depends(get_current_user), db: SessionLocal = Depends(get_db)):\n    \"\"\"Process an AI query from a user.\n\n    Sends the query to the OpenAI API and returns the response. The query and response\n    are associated with a chat ID for maintaining conversation context.\n    All queries and responses are stored in the database for future reference.\n\n    Args:\n        request: The HTTP request containing the query data\n        user: The authenticated user making the query\n        db: Database session dependency\n\n    Returns:\n        dict: The AI response along with query details\n\n    Raises:\n        HTTPException: 400 if required parameters are missing\n        HTTPException: 500 if OpenAI API call fails\n    \"\"\"\n    # First check if there's any content in the request body\n    body_bytes = await request.body()\n    if not body_bytes:\n        return JSONResponse({\"error\": \"Empty request body\"}, status_code=400)\n\n    # Try to parse the JSON body\n    try:\n        body = await request.json()\n    except json.JSONDecodeError as json_err:\n        return JSONResponse({\"error\": f\"Invalid JSON in request body: {str(json_err)}\"}, status_code=400)\n\n    try:\n\n        # Check for required fields\n        if not body.get(\"query\"):\n            return JSONResponse(status_code=400, content={\"error\": \"No query provided\"})\n\n        user_query = body.get(\"query\")\n        chat_id = body.get(\"chat_id\", \"\")\n        model = body.get(\"model\", \"gpt-3.5-turbo\")\n        max_tokens = body.get(\"max_tokens\", 1024)\n        temperature = body.get(\"temperature\", 0.7)\n\n        # Log the incoming query\n        log_ai_call(user_query, model, \"/query\")\n\n        # Create a new query record in the database (without response yet)\n        db_query = Query(\n            userId=user.userId,\n            chatId=chat_id,\n            query_text=user_query\n        )\n        db.add(db_query)\n        db.commit()\n        db.refresh(db_query)\n\n        from aiagent.memory.memory_manager import LongTermMemoryManager, ShortTermMemoryManager\n        long_term_memory = LongTermMemoryManager()\n        short_term_memory = ShortTermMemoryManager()\n\n        # Call your AI agent with try/except to handle Vercel environment limitations\n        try:\n            from aiagent.handler.query import ask_ai\n\n            # Set up auxiliary data for the AI query\n            aux_data = {\n                \"username\": user.username,\n                \"user_id\": user.userId,\n                \"chat_id\": chat_id,\n                \"query_id\": db_query.queryId,\n                \"client_info\": {\n                    \"model\": model,\n                    \"max_tokens\": max_tokens,\n                    \"temperature\": temperature\n                }\n            }\n\n            # Send query to AI agent\n            response = ask_ai(\n                query=user_query,\n                max_tokens=max_tokens,\n                temperature=temperature,\n                aux_data=aux_data\n            )\n        except FileNotFoundError as file_err:\n            # Handle missing files in Vercel environment\n            log_error(f\"AI agent file not found: {str(file_err)}\", exc=file_err, endpoint=\"/query\")\n            if os.environ.get(\"VERCEL\"):\n                # In Vercel, return a graceful error message for testing purposes\n                response = \"The AI agent is not fully configured in this environment. This is a test instance.\"\n            else:\n                # In non-Vercel environments, still raise the error\n                raise file_err\n\n        # Log the response\n        log_ai_response(response, \"/query\")\n\n        # Update the query record with the response\n        db_query.response = response\n        db.commit()\n\n        return {\n            \"response\": response,\n            \"query\": user_query,\n            \"chat_id\": chat_id,\n            \"queryId\": db_query.queryId\n        }\n    except Exception as e:\n        db.rollback()  # Rollback transaction on error\n        log_error(f\"AI query failed: {str(e)}\", exc=e, endpoint=\"/query\")\n        raise HTTPException(status_code=500, detail=f\"Error processing query: {str(e)}\")\n</code></pre>"},{"location":"api/routes/#server.routes.register","title":"<code>register(req: RegisterRequest, db: SessionLocal = Depends(get_db))</code>","text":"<p>Register a new user in the system.</p> <p>Parameters:</p> Name Type Description Default <code>req</code> <code>RegisterRequest</code> <p>The registration request containing username and password</p> required <code>db</code> <code>SessionLocal</code> <p>Database session dependency</p> <code>Depends(get_db)</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Registration confirmation with userId</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>400 error if username already exists</p> Source code in <code>server/routes.py</code> <pre><code>@router.post(\"/register\")\ndef register(req: RegisterRequest, db: SessionLocal = Depends(get_db)):\n    \"\"\"Register a new user in the system.\n\n    Args:\n        req: The registration request containing username and password\n        db: Database session dependency\n\n    Returns:\n        dict: Registration confirmation with userId\n\n    Raises:\n        HTTPException: 400 error if username already exists\n    \"\"\"\n    if db.query(User).filter(User.username == req.username).first():\n        raise HTTPException(status_code=400, detail=\"User already exists\")\n    hashed_pw = get_password_hash(req.password)\n    user = User(username=req.username, hashed_password=hashed_pw)\n    db.add(user)\n    db.commit()\n    db.refresh(user)\n    user_folder = os.path.join(ASSETS_FOLDER, str(user.userId))\n    os.makedirs(user_folder, exist_ok=True)\n    return {\"message\": \"Registered successfully\", \"userId\": user.userId}\n</code></pre>"},{"location":"api/routes/#server.routes.root","title":"<code>root()</code>","text":"<p>Root endpoint that confirms the API is running.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A simple message indicating the API is operational</p> Source code in <code>server/routes.py</code> <pre><code>@router.get(\"/\")\ndef root():\n    \"\"\"Root endpoint that confirms the API is running.\n\n    Returns:\n        dict: A simple message indicating the API is operational\n    \"\"\"\n    return {\"message\": \"LMS API is running\"}\n</code></pre>"},{"location":"api/routes/#server.routes.set_file_metadata","title":"<code>set_file_metadata(fileId: int, update: MetadataUpdate, user: User = Depends(get_current_user), db: SessionLocal = Depends(get_db))</code>","text":"<p>Set or update metadata for a file.</p> <p>Adds or updates metadata key-value pairs for a file. Only the owner of the file can modify metadata.</p> <p>Parameters:</p> Name Type Description Default <code>fileId</code> <code>int</code> <p>ID of the file to set metadata for</p> required <code>metadata</code> <p>Dictionary of metadata key-value pairs</p> required <code>user</code> <code>User</code> <p>The authenticated user making the request</p> <code>Depends(get_current_user)</code> <code>db</code> <code>SessionLocal</code> <p>Database session dependency</p> <code>Depends(get_db)</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Updated metadata for the file</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>404 if file not found</p> <code>HTTPException</code> <p>403 if user doesn't own the file</p> Source code in <code>server/routes.py</code> <pre><code>@router.post(\"/files/{fileId}/metadata\")\ndef set_file_metadata(fileId: int, update: MetadataUpdate, user: User = Depends(get_current_user), db: SessionLocal = Depends(get_db)):\n    \"\"\"Set or update metadata for a file.\n\n    Adds or updates metadata key-value pairs for a file.\n    Only the owner of the file can modify metadata.\n\n    Args:\n        fileId: ID of the file to set metadata for\n        metadata: Dictionary of metadata key-value pairs\n        user: The authenticated user making the request\n        db: Database session dependency\n\n    Returns:\n        dict: Updated metadata for the file\n\n    Raises:\n        HTTPException: 404 if file not found\n        HTTPException: 403 if user doesn't own the file\n    \"\"\"\n    try:\n        # Check if file exists and belongs to the user\n        file_record = db.query(DBFile).filter(DBFile.fileId == fileId).first()\n        if not file_record:\n            raise HTTPException(status_code=404, detail=\"File not found\")\n\n        if file_record.userId != user.userId:\n            raise HTTPException(status_code=403, detail=\"You don't have permission to modify this file's metadata\")\n\n        # Add or update metadata entries\n        updated_keys = []\n        for key, value in update.metadata.items():\n            # Skip invalid keys\n            if not key or not isinstance(key, str):\n                continue\n\n            # Look for existing metadata with this key\n            existing = db.query(FileMetadata).filter(\n                FileMetadata.fileId == fileId,\n                FileMetadata.key == key\n            ).first()\n\n            if existing:\n                # Update existing metadata\n                existing.value = str(value)\n                updated_keys.append(key)\n            else:\n                # Create new metadata entry\n                new_metadata = FileMetadata(\n                    fileId=fileId,\n                    key=key,\n                    value=str(value)\n                )\n                db.add(new_metadata)\n                updated_keys.append(key)\n\n        db.commit()\n\n        # Get all metadata for this file\n        all_metadata = {}\n        metadata_records = db.query(FileMetadata).filter(FileMetadata.fileId == fileId).all()\n        for record in metadata_records:\n            all_metadata[record.key] = record.value\n\n        return {\n            \"fileId\": fileId,\n            \"metadata\": all_metadata,\n            \"updated_keys\": updated_keys\n        }\n    except HTTPException:\n        raise\n    except Exception as e:\n        db.rollback()\n        log_error(f\"Error updating file metadata: {str(e)}\", exc=e, endpoint=f\"/files/{fileId}/metadata\")\n        raise HTTPException(status_code=500, detail=f\"Error updating file metadata: {str(e)}\")\n</code></pre>"},{"location":"api/routes/#server.routes.upload_file","title":"<code>upload_file(file: FastAPIFile = File(...), user: User = Depends(get_current_user), db: SessionLocal = Depends(get_db))</code>  <code>async</code>","text":"<p>Upload a file to the system.</p> <p>The file is stored in the user's directory within the assets folder and tracked in the database.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>UploadFile</code> <p>The file to upload</p> <code>File(...)</code> <code>user</code> <code>User</code> <p>The authenticated user uploading the file</p> <code>Depends(get_current_user)</code> <code>db</code> <code>SessionLocal</code> <p>Database session dependency</p> <code>Depends(get_db)</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Information about the uploaded file</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>400 if file is too large</p> <code>HTTPException</code> <p>500 if file upload fails</p> Source code in <code>server/routes.py</code> <pre><code>@router.post(\"/upload\")\nasync def upload_file(file: FastAPIFile = File(...), user: User = Depends(get_current_user), db: SessionLocal = Depends(get_db)):\n    \"\"\"Upload a file to the system.\n\n    The file is stored in the user's directory within the assets folder and tracked in the database.\n\n    Args:\n        file: The file to upload\n        user: The authenticated user uploading the file\n        db: Database session dependency\n\n    Returns:\n        dict: Information about the uploaded file\n\n    Raises:\n        HTTPException: 400 if file is too large\n        HTTPException: 500 if file upload fails\n    \"\"\"\n    try:\n        # Read file contents\n        contents = await file.read()\n\n        # Check file size\n        file_size = len(contents)\n        if file_size &gt; user.max_file_size:\n            raise HTTPException(status_code=400, detail=\"File too large\")\n\n        # Detect MIME type\n        import mimetypes\n        content_type = mimetypes.guess_type(file.filename)[0] or \"application/octet-stream\"\n\n        # Create database record - using the improved schema with content column\n        db_file = DBFile()\n        db_file.filename = file.filename\n        db_file.userId = user.userId\n        db_file.size = file_size\n        db_file.content = contents  # Store binary content directly in the database\n        db_file.content_type = content_type\n\n        # Also save to filesystem in development environment (not on Vercel) for easier debugging\n        if not os.environ.get(\"VERCEL\") and not os.environ.get(\"READ_ONLY_FS\"):\n            user_folder = os.path.join(ASSETS_FOLDER, str(user.userId))\n            os.makedirs(user_folder, exist_ok=True)\n            filepath = os.path.join(user_folder, file.filename)\n            with open(filepath, \"wb\") as f:\n                f.write(contents)\n            db_file.path = filepath\n\n        # Save the file first to get its ID\n        db.add(db_file)\n        db.commit()\n        db.refresh(db_file)\n\n        # Now create the initial version with the file ID\n        initial_version = FileVersion(\n            fileId=db_file.fileId,\n            userId=user.userId,\n            content=contents,\n            size=file_size,\n            version_number=1\n        )\n        db.add(initial_version)\n\n        # Add basic metadata\n        content_type_metadata = FileMetadata(\n            fileId=db_file.fileId,\n            key=\"content_type\",\n            value=content_type\n        )\n        db.add(content_type_metadata)\n\n        db.commit()\n\n        return {\n            \"filename\": file.filename, \n            \"size\": file_size,\n            \"fileId\": db_file.fileId,\n            \"content_type\": content_type,\n            \"version\": 1,\n            \"uploaded_at\": db_file.uploaded_at\n        }\n    except Exception as e:\n        db.rollback()\n        log_error(f\"File upload failed: {str(e)}\", exc=e, endpoint=\"/upload\")\n        raise HTTPException(status_code=500, detail=f\"Error uploading file: {str(e)}\")\n</code></pre>"},{"location":"api/routes/#server.routes.upload_file_version","title":"<code>upload_file_version(fileId: int, file: FastAPIFile = File(...), user: User = Depends(get_current_user), db: SessionLocal = Depends(get_db))</code>  <code>async</code>","text":"<p>Upload a new version of an existing file.</p> <p>Creates a new version of the file while preserving the original. Only the owner of the file can add new versions.</p> <p>Parameters:</p> Name Type Description Default <code>fileId</code> <code>int</code> <p>ID of the file to create a version for</p> required <code>file</code> <code>UploadFile</code> <p>The new version of the file</p> <code>File(...)</code> <code>user</code> <code>User</code> <p>The authenticated user making the request</p> <code>Depends(get_current_user)</code> <code>db</code> <code>SessionLocal</code> <p>Database session dependency</p> <code>Depends(get_db)</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Information about the newly created version</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>404 if file not found</p> <code>HTTPException</code> <p>403 if user doesn't own the file</p> <code>HTTPException</code> <p>400 if file is too large</p> Source code in <code>server/routes.py</code> <pre><code>@router.post(\"/files/{fileId}/versions\")\nasync def upload_file_version(fileId: int, file: FastAPIFile = File(...), user: User = Depends(get_current_user), db: SessionLocal = Depends(get_db)):\n    \"\"\"Upload a new version of an existing file.\n\n    Creates a new version of the file while preserving the original.\n    Only the owner of the file can add new versions.\n\n    Args:\n        fileId: ID of the file to create a version for\n        file: The new version of the file\n        user: The authenticated user making the request\n        db: Database session dependency\n\n    Returns:\n        dict: Information about the newly created version\n\n    Raises:\n        HTTPException: 404 if file not found\n        HTTPException: 403 if user doesn't own the file\n        HTTPException: 400 if file is too large\n    \"\"\"\n    try:\n        # Check if file exists and belongs to the user\n        original_file = db.query(DBFile).filter(DBFile.fileId == fileId).first()\n        if not original_file:\n            raise HTTPException(status_code=404, detail=\"File not found\")\n\n        if original_file.userId != user.userId:\n            raise HTTPException(status_code=403, detail=\"You don't have permission to modify this file\")\n\n        # Read file contents\n        contents = await file.read()\n\n        # Check file size\n        file_size = len(contents)\n        if file_size &gt; user.max_file_size:\n            raise HTTPException(status_code=400, detail=\"File too large\")\n\n        # Get the latest version number\n        latest_version = db.query(FileVersion).filter(\n            FileVersion.fileId == fileId\n        ).order_by(FileVersion.version_number.desc()).first()\n\n        new_version_number = 1\n        if latest_version:\n            new_version_number = latest_version.version_number + 1\n\n        # Create new version\n        new_version = FileVersion(\n            fileId=fileId,\n            userId=user.userId,\n            content=contents,\n            size=file_size,\n            version_number=new_version_number\n        )\n\n        db.add(new_version)\n        db.commit()\n        db.refresh(new_version)\n\n        # Update the main file record with the latest content\n        original_file.content = contents\n        original_file.size = file_size\n        db.commit()\n\n        return {\n            \"fileId\": fileId,\n            \"filename\": original_file.filename,\n            \"version\": new_version_number,\n            \"size\": file_size,\n            \"created_at\": new_version.created_at\n        }\n    except HTTPException:\n        raise\n    except Exception as e:\n        db.rollback()\n        log_error(f\"Error uploading file version: {str(e)}\", exc=e, endpoint=f\"/files/{fileId}/versions\")\n        raise HTTPException(status_code=500, detail=f\"Error uploading file version: {str(e)}\")\n</code></pre>"},{"location":"dev-guide/architecture/","title":"System Architecture","text":"<p>The LMS platform follows a modern microservices architecture built with Python FastAPI for the backend and a lightweight frontend. This scalable design enables rapid iteration and robust performance.</p>"},{"location":"dev-guide/architecture/#system-components","title":"System Components","text":"<pre><code>flowchart TD\n    Client[Client Browser] ---&gt; Frontend[Frontend SPA]\n    Frontend ---&gt; API[FastAPI Backend]\n    API ---&gt; Auth[Authentication Service]\n    API ---&gt; DB[(PostgreSQL Database)]\n    API ---&gt; AI[AI Processing Service]\n    API ---&gt; Files[File Storage Service]\n\n    subgraph Cloud Infrastructure\n        API\n        Auth\n        DB\n        AI\n        Files\n    end\n\n    style Client fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style Frontend fill:#d1c4e9,stroke:#333,stroke-width:2px\n    style API fill:#bbdefb,stroke:#333,stroke-width:2px\n    style Auth fill:#c8e6c9,stroke:#333,stroke-width:2px\n    style DB fill:#ffecb3,stroke:#333,stroke-width:2px\n    style AI fill:#f8bbd0,stroke:#333,stroke-width:2px\n    style Files fill:#d7ccc8,stroke:#333,stroke-width:2px</code></pre>"},{"location":"dev-guide/architecture/#key-technologies","title":"Key Technologies","text":"<ul> <li> <p>:material-api: FastAPI   High-performance API framework with automatic documentation</p> </li> <li> <p>:simple-postgresql: PostgreSQL   Robust relational database for structured data storage</p> </li> <li> <p>:simple-openai: OpenAI Integration   AI capabilities for enhanced learning experiences</p> </li> <li> <p>:simple-vercel: Vercel Deployment   Serverless infrastructure for scalable performance</p> </li> </ul>"},{"location":"dev-guide/architecture/#high-level-architecture","title":"High-Level Architecture","text":"<p>The LMS is built using a modern web application architecture with a clear separation between backend and frontend components.</p> <pre><code>graph TD\n    Client[Web Client] &lt;--&gt; API[FastAPI Backend]\n    API &lt;--&gt; DB[(PostgreSQL Database)]\n    API &lt;--&gt; FileSystem[File Storage]\n    API &lt;--&gt; OpenAI[OpenAI API]\n\n    subgraph Backend\n        API\n        DB\n        FileSystem\n        OpenAI\n    end</code></pre>"},{"location":"dev-guide/architecture/#component-overview","title":"Component Overview","text":""},{"location":"dev-guide/architecture/#backend-components","title":"Backend Components","text":"<p>The backend system consists of several key components:</p> <ol> <li>REST API (FastAPI): Handles all HTTP requests</li> <li>Authentication System: Manages user credentials and session tokens</li> <li>Database Layer: Persists application data</li> <li>File Management: Handles file uploads and downloads</li> <li>OpenAI Integration: Connects to OpenAI for AI-powered responses</li> </ol>"},{"location":"dev-guide/architecture/#database-schema","title":"Database Schema","text":"<p>The database schema represents the core data model:</p> <pre><code>erDiagram\n    User {\n        int id PK\n        string username\n        string password_hash\n    }\n    File {\n        int id PK\n        string filename\n        int user_id FK\n        string path\n        datetime created_at\n    }\n    Query {\n        int id PK\n        int user_id FK\n        string chat_id\n        string query_text\n        string response\n        datetime timestamp\n    }\n\n    User ||--o{ File : uploads\n    User ||--o{ Query : makes</code></pre>"},{"location":"dev-guide/architecture/#request-flow","title":"Request Flow","text":"<p>The following diagram illustrates a typical request flow through the system:</p> <pre><code>sequenceDiagram\n    participant C as Client\n    participant A as API Server\n    participant D as Database\n    participant O as OpenAI API\n\n    C-&gt;&gt;A: HTTP Request\n    A-&gt;&gt;A: Validate Request\n    A-&gt;&gt;A: Authenticate User (if needed)\n\n    alt File Upload\n        A-&gt;&gt;A: Save File to Storage\n        A-&gt;&gt;D: Save File Metadata\n        A-&gt;&gt;C: Return File Info\n    else Query AI\n        A-&gt;&gt;D: Log Query\n        A-&gt;&gt;O: Forward Query to OpenAI\n        O-&gt;&gt;A: AI Response\n        A-&gt;&gt;D: Save Response\n        A-&gt;&gt;C: Return Response\n    else File Retrieval\n        A-&gt;&gt;D: Query File Metadata\n        A-&gt;&gt;A: Get File from Storage\n        A-&gt;&gt;C: Return File\n    end</code></pre>"},{"location":"dev-guide/architecture/#code-organization","title":"Code Organization","text":"<p>The codebase is organized into the following structure:</p> <pre><code>server/\n\u251c\u2500\u2500 main.py         # Application entry point\n\u251c\u2500\u2500 auth.py         # Authentication logic\n\u251c\u2500\u2500 db.py           # Database models and connection\n\u251c\u2500\u2500 routes.py       # API route handlers\n\u2514\u2500\u2500 utils.py        # Utility functions\n</code></pre>"},{"location":"dev-guide/architecture/#core-modules","title":"Core Modules","text":"<ol> <li>main.py: Initializes the FastAPI application, middleware, and routes</li> <li>auth.py: Contains authentication logic including JWT token handling</li> <li>db.py: Defines SQLAlchemy database models and connection setup</li> <li>routes.py: Implements API endpoints and business logic</li> </ol>"},{"location":"dev-guide/architecture/#deployment-architecture","title":"Deployment Architecture","text":"<p>In production, the system is deployed on Vercel with a Supabase PostgreSQL database:</p> <pre><code>graph LR\n    Client[Web Browser] --&gt; Vercel[Vercel Edge]\n    Vercel --&gt; API[FastAPI Function]\n    API --&gt; Supabase[Supabase PostgreSQL]\n    API --&gt; OpenAI[OpenAI API]</code></pre>"},{"location":"dev-guide/architecture/#security-considerations","title":"Security Considerations","text":"<p>The LMS implements several security measures:</p> <ol> <li>JWT Authentication: Secure token-based authentication</li> <li>Password Hashing: Passwords are securely hashed using bcrypt</li> <li>CORS Protection: Configured to prevent cross-origin attacks</li> <li>Input Validation: Request validation using Pydantic models</li> </ol>"},{"location":"dev-guide/architecture/#future-architecture-improvements","title":"Future Architecture Improvements","text":"<p>Potential improvements to consider:</p> <ol> <li>Caching Layer: Implement Redis for response caching</li> <li>Message Queue: Add RabbitMQ/Kafka for async processing</li> <li>CDN Integration: Use a CDN for file delivery</li> <li>Microservices: Split into domain-specific microservices</li> <li>Real-time Communication: Add WebSocket support</li> </ol>"},{"location":"dev-guide/contributing/","title":"Contributing Guide","text":""},{"location":"dev-guide/contributing/#welcome-to-the-lms-community","title":"Welcome to the LMS Community","text":"<p>Thank you for your interest in contributing to the LMS platform! This document provides guidelines and instructions for contributing to the project. Whether you're fixing bugs, adding features, or improving documentation, your contributions are greatly appreciated.</p>"},{"location":"dev-guide/contributing/#development-workflow","title":"Development Workflow","text":"<pre><code>flowchart LR\n    A[Fork Repository] --&gt; B[Create Branch]\n    B --&gt; C[Make Changes]\n    C --&gt; D[Run Tests]\n    D --&gt; E[Submit PR]\n    E --&gt; F[Code Review]\n    F --&gt; G[Merge]\n\n    style A fill:#d1c4e9,stroke:#333,stroke-width:1px\n    style B fill:#c8e6c9,stroke:#333,stroke-width:1px\n    style C fill:#bbdefb,stroke:#333,stroke-width:1px\n    style D fill:#ffecb3,stroke:#333,stroke-width:1px\n    style E fill:#f8bbd0,stroke:#333,stroke-width:1px\n    style F fill:#d7ccc8,stroke:#333,stroke-width:1px\n    style G fill:#b2dfdb,stroke:#333,stroke-width:1px</code></pre>"},{"location":"dev-guide/contributing/#getting-started","title":"Getting Started","text":"<ol> <li>Fork the repository on GitHub</li> <li>Clone your fork:    <pre><code>git clone https://github.com/YOUR-USERNAME/LMS.git\ncd LMS\n</code></pre></li> <li>Set up your development environment by following the Installation Guide</li> <li>Create a new branch for your feature or bugfix:    <pre><code>git checkout -b feature/your-feature-name\n</code></pre></li> </ol>"},{"location":"dev-guide/contributing/#development-workflow_1","title":"Development Workflow","text":""},{"location":"dev-guide/contributing/#coding-standards","title":"Coding Standards","text":"<ul> <li>Follow PEP 8 style guidelines for Python code</li> <li>Use meaningful variable and function names</li> <li>Include docstrings for all functions, classes, and modules</li> <li>Write unit tests for new functionality</li> </ul>"},{"location":"dev-guide/contributing/#docstring-format","title":"Docstring Format","text":"<p>Use Google-style docstrings for Python code:</p> <pre><code>def function_name(param1, param2):\n    \"\"\"Short description of function.\n\n    Longer description of function explaining details.\n\n    Args:\n        param1: Description of param1\n        param2: Description of param2\n\n    Returns:\n        Description of return value\n\n    Raises:\n        ExceptionType: Description of when this exception is raised\n    \"\"\"\n    # Function implementation\n</code></pre>"},{"location":"dev-guide/contributing/#testing","title":"Testing","text":"<ul> <li>Write tests for all new features and bug fixes</li> <li>Run tests before submitting a pull request:   <pre><code>pytest\n</code></pre></li> </ul>"},{"location":"dev-guide/contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Update documentation for any new features or changes</li> <li>Run all tests to ensure they pass</li> <li>Submit a pull request to the main repository</li> <li>Address any feedback from code reviews</li> </ol>"},{"location":"dev-guide/contributing/#commit-message-guidelines","title":"Commit Message Guidelines","text":"<p>Follow the conventional commits specification for commit messages:</p> <ul> <li>feat: A new feature</li> <li>fix: A bug fix</li> <li>docs: Documentation only changes</li> <li>style: Changes that do not affect the meaning of the code</li> <li>refactor: A code change that neither fixes a bug nor adds a feature</li> <li>perf: A code change that improves performance</li> <li>test: Adding missing tests or correcting existing tests</li> <li>chore: Changes to the build process or auxiliary tools</li> </ul> <p>Example: <pre><code>feat(auth): add password reset functionality\n</code></pre></p>"},{"location":"dev-guide/contributing/#documentation","title":"Documentation","text":"<p>When adding or modifying features, make sure to update the documentation:</p> <ol> <li>Update relevant documentation in the <code>/docs</code> directory</li> <li>Include clear docstrings in your code</li> <li>Add comments for complex logic</li> </ol>"},{"location":"dev-guide/contributing/#code-review-process","title":"Code Review Process","text":"<p>All submissions require review before being merged:</p> <ol> <li>A maintainer will review your pull request</li> <li>Changes may be requested</li> <li>Once approved, your changes will be merged</li> </ol>"},{"location":"dev-guide/contributing/#development-environment-setup","title":"Development Environment Setup","text":"<p>For a consistent development environment:</p> <ol> <li>Use a virtual environment</li> <li>Install development dependencies:    <pre><code>pip install -r requirements-dev.txt\n</code></pre></li> <li>Install pre-commit hooks:    <pre><code>pre-commit install\n</code></pre></li> </ol>"},{"location":"dev-guide/contributing/#contact","title":"Contact","text":"<p>If you have questions or need help:</p> <ul> <li>Open an issue on GitHub</li> <li>Contact the project maintainers</li> </ul>"},{"location":"user-guide/configuration/","title":"Configuration Guide","text":""},{"location":"user-guide/configuration/#environment-variables","title":"Environment Variables","text":"<p>The LMS platform uses environment variables for configuration. These can be set in a <code>.env</code> file for local development or as environment variables in your production environment.</p>"},{"location":"user-guide/configuration/#required-environment-variables","title":"Required Environment Variables","text":"Variable Description Example <code>DATABASE_URL</code> PostgreSQL connection string <code>postgresql://user:password@localhost:5432/lms</code> <code>SECRET_KEY</code> JWT signing key (keep this secret!) <code>your-256-bit-secret-key</code> <code>OPENAI_API_KEY</code> OpenAI API key for AI features <code>sk-...</code>"},{"location":"user-guide/configuration/#optional-environment-variables","title":"Optional Environment Variables","text":"Variable Description Default Example <code>ALGORITHM</code> JWT signing algorithm <code>HS256</code> <code>HS256</code> <code>ACCESS_TOKEN_EXPIRE_MINUTES</code> JWT expiration time in minutes <code>60</code> <code>120</code> <code>PORT</code> Server port <code>7050</code> <code>8000</code> <code>VERCEL</code> Flag indicating Vercel deployment <code>null</code> <code>1</code>"},{"location":"user-guide/configuration/#configuration-examples","title":"Configuration Examples","text":""},{"location":"user-guide/configuration/#local-development","title":"Local Development","text":"<p>Create a <code>.env</code> file in the project root with your configuration:</p> <p><pre><code>DATABASE_URL=postgresql://lms_user:lms_password@localhost:5432/thoth\nSECRET_KEY=your-256-bit-secret-key\nOPENAI_API_KEY=your-openai-api-key\nACCESS_TOKEN_EXPIRE_MINUTES=60\nALGORITHM=HS256\nPORT=7050\n</code></pre> |----------|-------------|---------| | <code>DATABASE_URL</code> | PostgreSQL connection string | <code>postgresql://user:password@localhost:5432/lms_db</code> | | <code>SECRET_KEY</code> | Secret key for JWT token generation | <code>your-secure-secret-key</code> | | <code>OPENAI_API_KEY</code> | API key for OpenAI integration | <code>sk-...</code> | | <code>ACCESS_TOKEN_EXPIRE_MINUTES</code> | Token expiration time in minutes | <code>60</code> | | <code>ALGORITHM</code> | JWT token algorithm | <code>HS256</code> | | <code>PORT</code> | Server port | <code>7050</code> |</p>"},{"location":"user-guide/configuration/#configuration-methods","title":"Configuration Methods","text":"<p>There are several ways to set these environment variables:</p>"},{"location":"user-guide/configuration/#1-environment-file-env","title":"1. Environment File (.env)","text":"<p>Create a <code>.env</code> file in the project root:</p> <pre><code>DATABASE_URL=postgresql://lms_user:lms_password@localhost:5432/lms_db\nSECRET_KEY=your-secret-key-here\nOPENAI_API_KEY=your-openai-api-key\nACCESS_TOKEN_EXPIRE_MINUTES=60\nALGORITHM=HS256\nPORT=7050\n</code></pre>"},{"location":"user-guide/configuration/#2-system-environment-variables","title":"2. System Environment Variables","text":"<p>Set variables directly in your shell session:</p> macOS/LinuxWindows <pre><code>export DATABASE_URL=\"postgresql://lms_user:lms_password@localhost:5432/lms_db\"\nexport SECRET_KEY=\"your-secret-key-here\"\nexport OPENAI_API_KEY=\"your-openai-api-key\"\nexport ACCESS_TOKEN_EXPIRE_MINUTES=60\nexport ALGORITHM=\"HS256\"\nexport PORT=7050\n</code></pre> <pre><code>set DATABASE_URL=postgresql://lms_user:lms_password@localhost:5432/lms_db\nset SECRET_KEY=your-secret-key-here\nset OPENAI_API_KEY=your-openai-api-key\nset ACCESS_TOKEN_EXPIRE_MINUTES=60\nset ALGORITHM=HS256\nset PORT=7050\n</code></pre>"},{"location":"user-guide/configuration/#3-deployment-platform-variables","title":"3. Deployment Platform Variables","text":"<p>For production deployments on platforms like Vercel, set environment variables in the platform's dashboard:</p> <ol> <li>Log into your Vercel account</li> <li>Navigate to your project</li> <li>Go to \"Settings\" &gt; \"Environment Variables\"</li> <li>Add each variable and its value</li> <li>Deploy or redeploy your application</li> </ol>"},{"location":"user-guide/configuration/#database-configuration","title":"Database Configuration","text":""},{"location":"user-guide/configuration/#postgresql-connection-string","title":"PostgreSQL Connection String","text":"<p>The PostgreSQL connection string format is:</p> <pre><code>postgresql://[username]:[password]@[host]:[port]/[database]\n</code></pre> <p>For Supabase deployments with Vercel, use the Transaction pooler connection:</p> <pre><code>postgresql://postgres.[project-ref]:[password]@aws-0-[region].pooler.supabase.com:6543/postgres\n</code></pre> <p>IPv4 Compatibility</p> <p>When deploying to Vercel, use the Transaction pooler URL for Supabase connections, as direct connections are not IPv4 compatible.</p>"},{"location":"user-guide/configuration/#database-migrations","title":"Database Migrations","text":"<p>The LMS uses SQLAlchemy's <code>create_all()</code> method to automatically create database tables. For production, you should consider implementing proper migrations with tools like Alembic.</p>"},{"location":"user-guide/configuration/#file-storage-configuration","title":"File Storage Configuration","text":"<p>By default, files are stored in the local filesystem under the <code>assets</code> directory. For production deployments, consider configuring:</p> <ol> <li>Cloud Storage: Services like AWS S3 or Google Cloud Storage</li> <li>Content Delivery Network (CDN): For faster file delivery</li> <li>Storage Quotas: Set limits on user file storage</li> </ol>"},{"location":"user-guide/configuration/#security-configuration","title":"Security Configuration","text":""},{"location":"user-guide/configuration/#jwt-configuration","title":"JWT Configuration","text":"<p>For JWT token security, consider:</p> <ol> <li>Using a strong, random <code>SECRET_KEY</code></li> <li>Setting an appropriate <code>ACCESS_TOKEN_EXPIRE_MINUTES</code> (balance between security and user experience)</li> <li>Regularly rotating your secret keys</li> </ol>"},{"location":"user-guide/configuration/#cors-configuration","title":"CORS Configuration","text":"<p>Configure Cross-Origin Resource Sharing (CORS) based on your frontend domains:</p> <pre><code>origins = [\n    \"http://localhost:7040\",\n    \"https://your-frontend-domain.com\"\n]\n</code></pre>"},{"location":"user-guide/configuration/#openai-api-configuration","title":"OpenAI API Configuration","text":"<p>The OpenAI integration requires:</p> <ol> <li>A valid API key (set as <code>OPENAI_API_KEY</code>)</li> <li>Sufficient API credits for your usage volume</li> <li>Optionally, set model parameters like temperature, max tokens, etc.</li> </ol>"},{"location":"user-guide/configuration/#advanced-configuration","title":"Advanced Configuration","text":"<p>For advanced scenarios, you may need to modify the application code directly. Key configuration files include:</p> <ul> <li><code>server/main.py</code>: Main application configuration</li> <li><code>server/auth.py</code>: Authentication settings</li> <li><code>server/db.py</code>: Database connection</li> </ul>"},{"location":"user-guide/getting-started/","title":"Getting Started","text":""},{"location":"user-guide/getting-started/#overview","title":"Overview","text":"<p>Welcome to the LMS Platform! This guide will help you quickly set up and start using our powerful learning management system.</p>"},{"location":"user-guide/getting-started/#quick-start","title":"Quick Start","text":"For InstructorsFor Students <ol> <li>Create an Account - Register using your institution email</li> <li>Set Up Your Course - Create a new course and add modules</li> <li>Add Content - Upload learning materials and assignments</li> <li>Invite Students - Generate and share enrollment codes</li> </ol> <ol> <li>Create an Account - Register with your student email</li> <li>Join a Course - Use the enrollment code from your instructor</li> <li>Access Materials - Browse through course content</li> <li>Submit Assignments - Complete and upload assignments</li> </ol>"},{"location":"user-guide/getting-started/#system-requirements","title":"System Requirements","text":"Component Minimum Requirements Recommended Browser Chrome 80+, Firefox 72+, Edge 80+ Latest version Internet 1 Mbps connection 5+ Mbps connection Display 1280 x 720 resolution 1920 x 1080 or higher Disk Space 100 MB for cached content 1 GB for offline features <p>Pro Tip</p> <p>Enable browser notifications to receive instant updates about grades, announcements, and upcoming deadlines.</p>"},{"location":"user-guide/getting-started/#first-time-login","title":"First-time Login","text":"<ol> <li>Navigate to https://lms-swart-five.vercel.app</li> <li>Click on \"Register\" to create a new account</li> <li>Verify your email address</li> <li>Complete your user profile</li> <li>Start exploring the platform</li> </ol>"},{"location":"user-guide/getting-started/#overview_1","title":"Overview","text":"<p>The Learning Management System (LMS) provides a set of tools for managing learning resources, including file management, user authentication, and AI-assisted learning support.</p> <p>Before you begin, make sure you have:</p> <ul> <li>A modern web browser (Chrome, Firefox, Safari, or Edge)</li> <li>Internet connection</li> <li>User credentials (or the ability to register a new account)</li> </ul>"},{"location":"user-guide/getting-started/#basic-workflow","title":"Basic Workflow","text":"<pre><code>graph TD\n    A[Register/Login] --&gt; B[Upload Learning Resources]\n    B --&gt; C[Organize Content]\n    C --&gt; D[Interact with AI Assistant]\n    D --&gt; E[Track Progress]</code></pre>"},{"location":"user-guide/getting-started/#first-steps","title":"First Steps","text":"<ol> <li>Register an account - Use the <code>/register</code> endpoint or user interface to create a new account</li> <li>Log in - Authenticate using your credentials to receive an access token</li> <li>Upload your files - Start uploading learning materials</li> <li>Query the AI - Use the AI assistant to help with your learning</li> </ol>"},{"location":"user-guide/getting-started/#next-steps","title":"Next Steps","text":"<p>Once you're familiar with the basic functionality, you can:</p> <ul> <li>Organize your files</li> <li>Create learning pathways</li> <li>Integrate with external tools and services</li> <li>Customize your learning experience</li> </ul>"},{"location":"user-guide/getting-started/#tutorial-basic-usage","title":"Tutorial: Basic Usage","text":""},{"location":"user-guide/getting-started/#registration-and-login","title":"Registration and Login","text":"<ol> <li>Visit the system at https://lms-swart-five.vercel.app</li> <li>Click on \"Register\" and enter your username and password</li> <li>After successful registration, log in with your credentials</li> </ol>"},{"location":"user-guide/getting-started/#file-management","title":"File Management","text":"<p>Once logged in, you can:</p> <ul> <li>Upload files using the \"Upload\" feature</li> <li>View your files in the file list</li> <li>Download files as needed</li> <li>Delete files you no longer need</li> </ul>"},{"location":"user-guide/getting-started/#using-the-ai-assistant","title":"Using the AI Assistant","text":"<ol> <li>Navigate to the chat interface</li> <li>Enter your question about the learning material</li> <li>Receive AI-generated responses to help with your learning</li> </ol>"},{"location":"user-guide/installation/","title":"Installation Guide","text":""},{"location":"user-guide/installation/#prerequisites","title":"Prerequisites","text":"<p>Before installing the LMS platform, make sure you have the following prerequisites:</p>"},{"location":"user-guide/installation/#installation-steps","title":"Installation Steps","text":""},{"location":"user-guide/installation/#1-clone-the-repository","title":"1. Clone the Repository","text":"<pre><code>git clone https://github.com/gadm21/LMS.git\ncd LMS\n</code></pre>"},{"location":"user-guide/installation/#2-set-up-a-virtual-environment","title":"2. Set Up a Virtual Environment","text":"macOS/LinuxWindows <pre><code>python -m venv .venv\nsource .venv/bin/activate\n</code></pre> <pre><code>python -m venv .venv\n.venv\\Scripts\\activate\n</code></pre>"},{"location":"user-guide/installation/#3-install-dependencies","title":"3. Install Dependencies","text":"<pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"user-guide/installation/#4-database-setup","title":"4. Database Setup","text":"<ol> <li>Create a PostgreSQL database for the LMS system:</li> </ol> <pre><code>createdb lms_db\n</code></pre> <ol> <li>Create a database user (optional):</li> </ol> <pre><code>createuser lms_user -P\n# Enter password when prompted\n</code></pre> <ol> <li>Grant privileges:</li> </ol> <pre><code>GRANT ALL PRIVILEGES ON DATABASE lms_db TO lms_user;\n</code></pre>"},{"location":"user-guide/installation/#5-environment-variables","title":"5. Environment Variables","text":"<p>Create a <code>.env</code> file in the project root with the following variables:</p> <pre><code>DATABASE_URL=postgresql://lms_user:lms_password@localhost:5432/lms_db\nSECRET_KEY=your-secret-key-here\nOPENAI_API_KEY=your-openai-api-key\nACCESS_TOKEN_EXPIRE_MINUTES=60\nALGORITHM=HS256\nPORT=7050\n</code></pre>"},{"location":"user-guide/installation/#6-initialize-the-database","title":"6. Initialize the Database","text":"<p>The database tables will be created automatically when you first run the application.</p>"},{"location":"user-guide/installation/#running-the-application","title":"Running the Application","text":""},{"location":"user-guide/installation/#5-start-the-application","title":"5. Start the Application","text":"<pre><code>uvicorn server.main:app --reload --port 7050\n</code></pre> <p>The application will be available at http://localhost:7050.</p>"},{"location":"user-guide/installation/#vercel-deployment","title":"Vercel Deployment","text":"<p>The LMS platform can be deployed to Vercel for a serverless production environment. Follow these steps for deployment:</p>"},{"location":"user-guide/installation/#1-set-up-vercel-cli","title":"1. Set up Vercel CLI","text":"<pre><code>npm install -g vercel\nvercel login\n</code></pre>"},{"location":"user-guide/installation/#2-configure-environment-variables","title":"2. Configure Environment Variables","text":"<p>In your Vercel project settings, add the following environment variables:</p> <pre><code>DATABASE_URL=postgresql://postgres.otjjjagmwzswbinwxmfw:thothpassword@aws-0-us-east-1.pooler.supabase.com:6543/postgres\nSECRET_KEY=your_secret_key_here\nALGORITHM=HS256\nACCESS_TOKEN_EXPIRE_MINUTES=60\nOPENAI_API_KEY=your_openai_api_key\n</code></pre> <p>Important Database Connection Note</p> <p>For Vercel deployments, you must use the Supabase Transaction pooler URL format as shown above, not the direct connection URL. This is because Vercel's serverless functions require IPv4 connectivity which the direct connection doesn't support.</p>"},{"location":"user-guide/installation/#3-deploy-the-application","title":"3. Deploy the Application","text":"<pre><code>vercel\n</code></pre>"},{"location":"user-guide/installation/#4-set-up-api-routes","title":"4. Set up API Routes","text":"<p>Ensure your <code>vercel.json</code> file has the correct configuration for FastAPI routes:</p> <pre><code>{\n  \"version\": 2,\n  \"builds\": [\n    { \"src\": \"server/main.py\", \"use\": \"@vercel/python\" },\n    { \"src\": \"docs_build/**\", \"use\": \"@vercel/static\" }\n  ],\n  \"routes\": [\n    { \"src\": \"/docs/(.*)\", \"dest\": \"docs_build/$1\" },\n    { \"src\": \"/(.*)\", \"dest\": \"server/main.py\" }\n  ]\n}\n</code></pre> <p>This configuration enables serving both your FastAPI application and static documentation from the same Vercel domain.</p>"},{"location":"user-guide/installation/#verifying-the-installation","title":"Verifying the Installation","text":"<ol> <li>Open your browser and navigate to http://localhost:7050</li> <li>If everything is set up correctly, you'll see the API running</li> <li>You can check the API documentation at http://localhost:7050/docs</li> </ol>"},{"location":"user-guide/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/installation/#database-connection-issues","title":"Database Connection Issues","text":"<p>If you encounter database connection issues:</p> <ol> <li> <p>Check if PostgreSQL is running:    <pre><code>pg_isready\n</code></pre></p> </li> <li> <p>Verify your DATABASE_URL environment variable is correct</p> </li> <li> <p>Ensure the database user has the correct permissions</p> </li> </ol>"},{"location":"user-guide/installation/#api-not-starting","title":"API Not Starting","text":"<p>If the API fails to start:</p> <ol> <li>Check for error messages in the terminal</li> <li>Verify all dependencies are installed correctly</li> <li>Make sure all required environment variables are set</li> </ol>"},{"location":"user-guide/installation/#openai-api-issues","title":"OpenAI API Issues","text":"<p>If the AI assistant is not working:</p> <ol> <li>Verify your OpenAI API key is valid</li> <li>Check if you have sufficient credits in your OpenAI account</li> </ol>"}]}